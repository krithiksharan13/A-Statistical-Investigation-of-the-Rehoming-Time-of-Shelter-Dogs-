---
title: "Appendix"
output: pdf_document
date: "2025-12-09"
---

```{r}
#code to get my sample data as per instuctions given
load("rehoming.Rdata")
createsample(202000567)
save(mysample, file = "mysample.RData")
#--------------------------------------------------#
```

```{r}
load("mysample.RData")

#checking the dataframe
head(mysample)
str(mysample)
summary(mysample)

#finding total amount of NA values by the column
colSums(is.na(mysample))
```
```{r}
#Cleaning the data

# Individual missing indicators
is_missing_rehome   <- mysample$Rehomed == 99999
is_missing_breed    <- is.na(mysample$Breed)
is_missing_returned <- is.na(mysample$Returned)

# Counts
na_rehome   <- sum(is_missing_rehome)
na_breed    <- sum(is_missing_breed)
na_returned <- sum(is_missing_returned)

# Combination counts
na_rehome_breed    <- sum(is_missing_rehome & is_missing_breed)
na_breed_returned  <- sum(is_missing_breed & is_missing_returned)
na_rehome_returned <- sum(is_missing_rehome & is_missing_returned)

total_rows <- nrow(mysample)

missing_table <- data.frame(
  Category = c(
    "Rehomed missing (99999)",
    "Breed missing",
    "Returned missing",
    "Rehomed & Breed missing",
    "Breed & Returned missing",
    "Rehomed & Returned missing"
  ),
  Count = c(
    na_rehome,
    na_breed,
    na_returned,
    na_rehome_breed,
    na_breed_returned,
    na_rehome_returned
  ),
  Percentage = round(c(
    na_rehome   / total_rows * 100,
    na_breed    / total_rows * 100,
    na_returned / total_rows * 100,
    na_rehome_breed    / total_rows * 100,
    na_breed_returned  / total_rows * 100,
    na_rehome_returned / total_rows * 100
  ), 2)
)
missing_table
```

```{r}
#removing all the rows that have an NA Value
clean_data <- subset(mysample, Rehomed != 99999 & !is.na(Breed) & !is.na(Returned))


#Re-checking the presence of NA values
sum(clean_data$Rehomed == 99999)
sum(is.na(clean_data$Breed))
sum(is.na(clean_data$Returned))

#Displaying the row count before Vs After Cleaning
cat("Original dataset size:", total_rows, "\n")
cat("Cleaned dataset size:", nrow(clean_data), "\n")

```
```{r}
##Data Exploration

#Split the data by Breed
breedSplit <- split(clean_data, clean_data$Breed)
#add colours to the breeds
breeds <- names(breedSplit)
cols <- c("red", "blue", "darkgreen")
names(cols) <- breeds

#check the different breed names after the splitting
names(breedSplit)

#Generating numerical summaries table
num_summary <- do.call(rbind, lapply(breedSplit, function(d){
  c(
    n                = nrow(d),
    Rehome_mean      = mean(d$Rehomed, na.rm=TRUE),
    Rehome_median    = median(d$Rehomed, na.rm=TRUE),
    Rehome_sd        = sd(d$Rehomed, na.rm=TRUE),
    Rehome_min       = min(d$Rehomed, na.rm=TRUE),
    Rehome_max       = max(d$Rehomed, na.rm=TRUE),
    Visited_mean     = mean(d$Visited, na.rm=TRUE),
    Health_mean      = mean(d$Health,  na.rm=TRUE),
    Puppy_share      = mean(d$Age == "Puppy", na.rm=TRUE) # proportion puppies
  )
}))
num_summary <- round(as.data.frame(num_summary), 2)
num_summary$Breed <- rownames(num_summary)
num_summary <- num_summary[, c("Breed", setdiff(names(num_summary), "Breed"))]
num_summary

# Age composition per breed
table_age <- with(clean_data, table(Breed, Age))
table_age


# Returned share per breed
ret_share <- sapply(breedSplit, function(d) mean(d$Returned == "Yes", na.rm=TRUE))
round(ret_share, 3)
ret_share

```

```{r}
# Rehoming time - Visualization

# Boxplot
boxplot(Rehomed ~ Breed, data = clean_data,
        main = "Rehoming Time by Breed",
        xlab = "Breed", ylab = "Weeks to Rehome",fill='blue')

```
```{r}
# Overlaid density (base)
plot(NULL,
     xlim = range(clean_data$Rehomed, na.rm=TRUE),
     ylim = c(0, 0.06),
     xlab = "Weeks to Rehome",
     ylab = "Density",
     main = "Density of Rehoming Time by Breed")

for (b in breeds) {
  x <- breedSplit[[b]]$Rehomed
  x <- x[is.finite(x) & !is.na(x)]
  
  # Skip if density cannot be computed (e.g., n < 2)
  if (length(x) < 2 || length(unique(x)) < 2) next
  
  lines(density(x), lwd=2, col = cols[b])
}

legend("topright", legend = breeds, col = cols, lwd=2, bty="n")
```
```{r}
# Modelling & parameter estimation for rehoming time

fit_candidates <- function(x){
  x <- x[is.finite(x) & !is.na(x) & x > 0]  # ensure only valid, positive times
  
  m  <- mean(x)
  v  <- var(x)
  
  # Exponential: lambda = 1 / mean
  exp_rate <- 1/m
  
  # Gamma: shape = mean² / variance, rate = mean / variance
  gam_shape <- m^2 / v
  gam_rate  <- m / v
  
  # Lognormal: fit on log-scale
  lx <- log(x)
  ln_mu    <- mean(lx)
  ln_sigma <- sd(lx)
  
  return(list(
    mean = m, var = v,
    exponential = list(rate   = exp_rate),
    gamma       = list(shape  = gam_shape, rate = gam_rate),
    lognormal   = list(mu     = ln_mu,     sigma = ln_sigma)
  ))
}

#apply the parameters to each breed
fits <- lapply(breedSplit, function(d) fit_candidates(d$Rehomed))
fits

#Display as a table
fit_table <- do.call(rbind, lapply(names(fits), function(b){
  f <- fits[[b]]
  data.frame(
    Breed = b,
    Mean = round(f$mean, 3),
    Variance = round(f$var, 3),
    Exp_rate = round(f$exponential$rate, 4),
    Gamma_shape = round(f$gamma$shape, 4),
    Gamma_rate = round(f$gamma$rate, 4),
    Lognormal_mu = round(f$lognormal$mu, 4),
    Lognormal_sigma = round(f$lognormal$sigma, 4)
  )
}))

fit_table
```
```{r}
#Graphical checking of Models
par(mfrow=c(1,3))
for(b in names(breedSplit)) {
  x <- breedSplit[[b]]$Rehomed
  x <- x[is.finite(x) & !is.na(x) & x > 0]
  
  plot(ecdf(x), main=paste("ECDF:", b),
       xlab="Weeks", ylab="F(x)")
  
  f <- fits[[b]]$gamma
  curve(pgamma(x, shape=f$shape, rate=f$rate), add=TRUE, col="red")
}
par(mfrow=c(1,1))
```
```{r}
#Histogram for Rehome weeks
par(mfrow=c(1,3))
for (b in names(breedSplit)) {
  x <- breedSplit[[b]]$Rehomed
  hist(x, main=paste("Histogram of", b),
       xlab="Weeks to Rehome", col="lightblue", breaks=10)
}
par(mfrow=c(1,1))

```
```{r}
#Density plot
par(mfrow=c(1,3))
for (b in names(breedSplit)) {
  x <- breedSplit[[b]]$Rehomed
  d <- density(x)
  plot(d, main=paste("Density of", b),
       xlab="Weeks to Rehome", lwd=2)
}
par(mfrow=c(1,1))

```

```{r}
### Q-Q Plots for All Candidate Distributions ###
### (Normal, Exponential, Gamma, Lognormal) ###

qq_plots_for_breed <- function(x, breed_name, params){
  # Clean data
  x <- x[!is.na(x) & x > 0]
  n  <- length(x)
  p  <- ppoints(n)
  sx <- sort(x)
  
  # Extract parameters
  exp_rate <- params$exponential$rate
  gam_shape <- params$gamma$shape
  gam_rate  <- params$gamma$rate
  ln_mu     <- params$lognormal$mu
  ln_sigma  <- params$lognormal$sigma
  
  par(mfrow=c(2,2))
  
  ## 1. Normal QQ
  qqnorm(sx,
         main=paste(breed_name, "\nNormal QQ-Plot"),
         pch=19, cex=0.6)
  qqline(sx, col="red", lwd=2)
  
  ## 2. Exponential QQ
  exp_theoretical <- qexp(p, rate=exp_rate)
  qqplot(exp_theoretical, sx,
         main=paste(breed_name, "\nExponential QQ-Plot"),
         xlab="Exponential Quantiles",
         ylab="Sample Quantiles",
         pch=19, cex=0.6)
  abline(0,1,col="red", lwd=2)
  
  ## 3. Gamma QQ
  gamma_theoretical <- qgamma(p, shape=gam_shape, rate=gam_rate)
  qqplot(gamma_theoretical, sx,
         main=paste(breed_name, "\nGamma QQ-Plot"),
         xlab="Gamma Quantiles",
         ylab="Sample Quantiles",
         pch=19, cex=0.6)
  abline(0,1,col="red", lwd=2)
  
  ## 4. Lognormal QQ
  lnorm_theoretical <- qlnorm(p, meanlog=ln_mu, sdlog=ln_sigma)
  qqplot(lnorm_theoretical, sx,
         main=paste(breed_name, "\nLognormal QQ-Plot"),
         xlab="Lognormal Quantiles",
         ylab="Sample Quantiles",
         pch=19, cex=0.6)
  abline(0,1,col="red", lwd=2)
  
  par(mfrow=c(1,1))
}

# Run for all breeds
for (b in names(breedSplit)) {
  qq_plots_for_breed(breedSplit[[b]]$Rehomed, b, fits[[b]])
}
```
```{r}
# Function for t-interval
t_ci <- function(x, mu0 = 27, conf = 0.95){
  x <- x[!is.na(x)]
  out <- t.test(x, mu = mu0, conf.level = conf)
  return(c(mean = mean(x),
           lower = out$conf.int[1],
           upper = out$conf.int[2],
           p = out$p.value,
           method = "t-interval"))
}

# Function for z-interval
z_ci <- function(x, mu0 = 27, conf = 0.95){
  x <- x[!is.na(x)]
  n  <- length(x)
  m  <- mean(x)
  s  <- sd(x)
  z  <- qnorm(1 - (1-conf)/2)
  
  se <- s / sqrt(n)
  
  lower <- m - z*se
  upper <- m + z*se
  
  # z-test p-value
  z_stat <- (m - mu0) / se
  p_value <- 2 * (1 - pnorm(abs(z_stat)))
  
  return(c(mean = m, lower = lower, upper = upper, 
           p = p_value, method = "z-interval"))
}

# Extract vectors
labs <- breedSplit[["Labrador Retriever"]]$Rehomed
shi  <- breedSplit[["Shih Tzu"]]$Rehomed
sbt  <- breedSplit[["Staffordshire Bull Terrier"]]$Rehomed

# Compute intervals
ci_Labrador <- t_ci(labs)
ci_ShihTzu  <- t_ci(shi)
ci_SBT      <- z_ci(sbt)   # large sample → z-interval

# Combine into a table
ci_table <- rbind(
  "Labrador Retriever" = ci_Labrador,
  "Shih Tzu"           = ci_ShihTzu,
  "Staffordshire Bull Terrier" = ci_SBT
)

ci_table

```
```{r}
# ----- PREP: Construct clean CI table -----

ci_table_df <- data.frame(
  Breed = c("Labrador Retriever", "Shih Tzu", "Staffordshire Bull Terrier"),
  Mean  = c(20.46551724, 19.5, 19.17258883),
  Lower = c(17.78398209, 15.77275381, 17.69812593),
  Upper = c(23.14705240, 23.22724619, 20.64705173),
  Method = c("t-interval", "t-interval", "z-interval")
)

```

```{r}

# ----- VISUALISATION -----

library(ggplot2)

ggplot(ci_table_df, aes(x = Mean, y = Breed)) +
  
  # Horizontal confidence intervals (modern syntax)
  geom_errorbar(
    aes(xmin = Lower, xmax = Upper),
    orientation = "y",
    width = 0.25,
    linewidth = 1.2,
    colour = "steelblue"
  ) +
  
  # Mean point
  geom_point(size = 3.5, colour = "darkred") +
  
  # 27-week reference line
  geom_vline(xintercept = 27, linetype = "dashed",
             colour = "black", linewidth = 1) +
  
  labs(
    title = "95% Confidence Intervals for Mean Rehoming Time by Breed",
    x = "Rehoming Time (weeks)",
    y = "Breed"
  ) +
  
  theme_minimal(base_size = 14)
```

```{r}
#Function to compute CI for the difference in means
pair_ci <- function(data, b1, b2, conf = 0.95){
  sub <- subset(data, Breed %in% c(b1, b2))
  sub$Breed <- droplevels(sub$Breed)
  
  t_out <- t.test(Rehomed ~ Breed, data=sub, var.equal = FALSE, conf.level = conf)
  
  means <- tapply(sub$Rehomed, sub$Breed, mean)
  
  data.frame(
    Pair = paste(b1, "vs", b2),
    Mean_Diff = as.numeric(diff(means)),  # mean(b1) - mean(b2)
    Lower = t_out$conf.int[1],
    Upper = t_out$conf.int[2],
    p_value = t_out$p.value,
    Method = "Welch two-sample t-interval"
  )
}
```

```{r}
#Generating all 3 Comparisons
breed_names <- levels(clean_data$Breed)

ci_b1_b2 <- pair_ci(clean_data, breed_names[1], breed_names[2])
ci_b1_b3 <- pair_ci(clean_data, breed_names[1], breed_names[3])
ci_b2_b3 <- pair_ci(clean_data, breed_names[2], breed_names[3])

pairwise_table <- rbind(ci_b1_b2, ci_b1_b3, ci_b2_b3)

#To make the table values with 3 decimal places
pairwise_table_round <- pairwise_table
pairwise_table_round[,2:5] <- round(pairwise_table_round[,2:5], 3)
pairwise_table_round
```

```{r}
ggplot(pairwise_table_round, aes(x = Mean_Diff, y = Pair)) +
  
  geom_errorbar(
    aes(xmin = Lower, xmax = Upper),
    orientation = "y",
    width = 0.25,
    linewidth = 1.1,
    colour = "steelblue"
  ) +
  
  geom_point(size = 3.2, colour = "darkred") +
  
  geom_vline(xintercept = 0,
             linetype = "dashed",
             colour = "black",
             linewidth = 0.9) +
  
  labs(
    title = "95% Confidence Intervals for Difference in Mean Rehoming Time Between Breeds",
    x = "Difference in Mean (weeks)",
    y = "Breed Pair"
  ) +
  
  theme_minimal(base_size = 12) +
  
  theme(
    axis.text.y = element_text(size = 11, face = "bold"),   # larger Y labels
    axis.text.x = element_text(size = 10),
    plot.title = element_text(size = 14, face = "bold"),
    axis.title = element_text(size = 12)
  )

```
